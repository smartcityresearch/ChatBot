<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart City Temporal Data Visualization</title>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Axios for API calls -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .form-container {
            margin-bottom: 20px;
        }
        .query-input {
            width: 70%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .submit-btn {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        .submit-btn:hover {
            background-color: #45a049;
        }
        .chart-container {
            position: relative;
            margin: 20px 0;
            height: 400px;
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.05);
        }
        .widget-header {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #f0f0f0;
        }
        .response {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
        }
        .loading {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #666;
        }
        .error {
            padding: 15px;
            background-color: #ffe6e6;
            border-left: 4px solid #ff5555;
            margin-top: 20px;
        }
        /* Status cards like in the image */
        .status-cards {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        .status-card {
            flex: 1;
            max-width: 150px;
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 0 10px;
        }
        .card-number {
            font-size: 36px;
            font-weight: bold;
        }
        .card-label {
            font-size: 14px;
            color: #666;
        }
        .paid-card {
            border-left: 5px solid #00c853;
        }
        .pending-card {
            border-left: 5px solid #ff9800;
        }
        .overdue-card {
            border-left: 5px solid #f44336;
        }
        /* Progress chart style */
        .progress-container {
            text-align: center;
            padding: 20px;
        }
        .progress-title {
            font-size: 18px;
            margin-bottom: 15px;
        }
        .progress-percentage {
            font-size: 28px;
            font-weight: bold;
            color: #5c6bc0;
        }
        .progress-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
        }
        .no-parameter {
            padding: 15px;
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Smart City Temporal Data Visualization</h1>
        
        <div class="form-container">
            <form id="queryForm">
                <input type="text" id="queryInput" class="query-input" 
                    placeholder="Enter your query (e.g., 'What was the temperature for the past week?')" required>
                <button type="submit" class="submit-btn">Submit</button>
            </form>
        </div>
        
        <div id="loading" class="loading" style="display: none;">Loading data...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="noParameter" class="no-parameter" style="display: none;">No specific parameter detected in your query. Try being more specific (e.g., "What was the temperature for the past week?")</div>
        
        <div id="chartContainer" class="chart-container" style="display: none;">
            <div class="widget-header">Temporal Data Visualization</div>
            <canvas id="temporalChart"></canvas>
        </div>
        
        <div id="response" class="response" style="display: none;"></div>
    </div>

    <script>
        // Global variables
        let chart;
        let nodeData = {};
        let timeSeriesData = {};
        let parameterKeywords = {
            // Temperature parameters
            'temperature': ['temperature', 'temp', 'ambient temperature', 'celsius', 'fahrenheit'],
            
            // Humidity parameters
            'humidity': ['humidity', 'relative humidity', 'moisture'],
            
            // Air quality parameters
            'co2': ['co2', 'carbon dioxide'],
            'co': ['co', 'carbon monoxide'],
            'pm2.5': ['pm2.5', 'particulate matter', 'fine particles'],
            'pm10': ['pm10', 'coarse particles'],
            'gas': ['gas', 'tvoc', 'voc'],
            'air quality': ['aqi', 'air quality', 'air quality index'],
            
            // Water parameters
            'ph': ['ph', 'acidity'],
            'turbidity': ['turbidity', 'clarity', 'water clarity'],
            'tds': ['tds', 'total dissolved solids'],
            'conductivity': ['conductivity', 'water conductivity'],
            'water flow': ['flow', 'water flow', 'flow rate'],
            'water level': ['water level', 'level'],
            
            // Energy parameters
            'voltage': ['voltage', 'volts'],
            'current': ['current', 'ampere', 'amp'],
            'power': ['power', 'watt', 'kw', 'kilowatt'],
            'energy': ['energy', 'kwh', 'kilowatt hour'],
            
            // Light parameters
            'light': ['light', 'lux', 'brightness', 'illuminance'],
            
            // Pressure parameters
            'pressure': ['pressure', 'barometric pressure', 'atmospheric pressure'],
            
            // Noise parameters
            'noise': ['noise', 'sound', 'decibel', 'db']
        };
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            // Set up event listeners
            document.getElementById('queryForm').addEventListener('submit', handleSubmit);
        });
        
        // Function to extract parameter from query
        function extractParameterFromQuery(query) {
            query = query.toLowerCase();
            
            // Check each parameter keyword
            for (const paramType in parameterKeywords) {
                for (const keyword of parameterKeywords[paramType]) {
                    if (query.includes(keyword)) {
                        return paramType;
                    }
                }
            }
            
            return null;
        }
        
        // Function to find actual parameter name in data that matches the parameter type
        function findMatchingParameter(paramType, availableParams) {
            paramType = paramType.toLowerCase();
            
            // First check for exact match
            for (const param of availableParams) {
                if (param.toLowerCase() === paramType) {
                    return param;
                }
            }
            
            // Then check for keyword matches
            if (parameterKeywords[paramType]) {
                for (const keyword of parameterKeywords[paramType]) {
                    for (const param of availableParams) {
                        if (param.toLowerCase().includes(keyword)) {
                            return param;
                        }
                    }
                }
            }
            
            // Check if any available param contains the paramType
            for (const param of availableParams) {
                if (param.toLowerCase().includes(paramType)) {
                    return param;
                }
            }
            
            return null;
        }
        
        // Handle form submission
        async function handleSubmit(event) {
            event.preventDefault();
            
            const query = document.getElementById('queryInput').value.trim();
            if (!query) return;
            
            // Extract parameter from query before sending
            const parameterType = extractParameterFromQuery(query);
            
            // Show loading state
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('noParameter').style.display = 'none';
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('response').style.display = 'none';
            
            if (chart) {
                chart.destroy();
            }
            
            try {
                // Fetch data from the API
                const API_URL = 'http://localhost:8001/debug'; // Update with your actual API URL
                const response = await axios.post(API_URL, { query });
                
                // Process and display the data for the specific parameter
                processApiResponse(response.data, parameterType, query);
            } catch (error) {
                showError('Error fetching data: ' + (error.response?.data?.message || error.message));
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Process the API response
        function processApiResponse(data, parameterType, originalQuery) {
            // Check if we have temporal data
            if (!data.is_temporal || !data.time_period) {
                showError('This query does not appear to be temporal. Please try a query about historical data.');
                return;
            }
            
            // Check if we have node data
            if (!data.node_data || Object.keys(data.node_data).length === 0) {
                showError('No data available for the requested nodes.');
                return;
            }
            
            // Store the node data
            nodeData = data.node_data;
            
            // Display the query classification and response
            let responseText = '';
            if (data.parsed_response && data.parsed_response.classification) {
                responseText += `Query classified as: ${data.parsed_response.classification}\n`;
            }
            if (data.raw_classification_response) {
                responseText += `\n${data.raw_classification_response}`;
            }
            document.getElementById('response').textContent = responseText;
            document.getElementById('response').style.display = 'block';
            
            // Extract time series data
            extractTimeSeriesData();
            
            // If no parameter was specified
            if (!parameterType) {
                document.getElementById('noParameter').style.display = 'block';
                return;
            }
            
            // Get all available parameters
            const availableParams = Object.keys(timeSeriesData);
            
            // Check if we have any parameters
            if (availableParams.length === 0) {
                showError('No numeric parameters found in the data.');
                return;
            }
            
            // Find the matching parameter in the actual data
            const matchedParam = findMatchingParameter(parameterType, availableParams);
            
            if (matchedParam) {
                // Create chart for the matched parameter
                createChart(matchedParam);
            } else {
                showError(`No data found for parameter: "${parameterType}". Available parameters: ${availableParams.join(", ")}`);
            }
        }
        
        // Extract time series data from the node data
        function extractTimeSeriesData() {
            timeSeriesData = {};
            
            // Iterate through each node
            for (const nodeId in nodeData) {
                const nodeInfo = nodeData[nodeId];
                
                // Check if we have filtered data (for temporal queries)
                if (nodeInfo.filtered_data) {
                    // Go through each category in the filtered data
                    for (const category in nodeInfo.filtered_data) {
                        const categoryData = nodeInfo.filtered_data[category];
                        
                        // Check if we have data points
                        if (categoryData.data && categoryData.data.length > 0) {
                            // Extract all parameters except metadata
                            const firstDataPoint = categoryData.data[0];
                            
                            for (const param in firstDataPoint) {
                                // Skip metadata fields
                                if (!['node_id', 'timestamp', 'id', 'name', 'latitude', 'longitude', 'type', 'created_at'].includes(param)) {
                                    // Initialize this parameter if it doesn't exist
                                    if (!timeSeriesData[param]) {
                                        timeSeriesData[param] = {
                                            timestamps: [],
                                            values: [],
                                            nodeId: nodeId,
                                            category: category
                                        };
                                    }
                                    
                                    // Add all data points for this parameter
                                    categoryData.data.forEach(point => {
                                        if (point[param] !== undefined) {
                                            // Use created_at if timestamp is not available
                                            const timestamp = new Date(point.timestamp || point.created_at);
                                            
                                            // Skip if date is invalid
                                            if (isNaN(timestamp.getTime())) {
                                                return;
                                            }
                                            
                                            // Try to convert to number if possible
                                            let value;
                                            try {
                                                value = parseFloat(point[param]);
                                                if (isNaN(value)) {
                                                    value = point[param];
                                                }
                                            } catch (e) {
                                                value = point[param];
                                            }
                                            
                                            timeSeriesData[param].timestamps.push(timestamp);
                                            timeSeriesData[param].values.push(value);
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Format date for display
        function formatDate(date) {
            if (!date || isNaN(date.getTime())) {
                return "Invalid Date";
            }
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }
        
        // Create a chart for the selected parameter
        function createChart(parameter) {
            if (chart) {
                chart.destroy();
            }
            
            if (!timeSeriesData[parameter]) {
                showError(`No data available for parameter: ${parameter}`);
                return;
            }
            
            const data = timeSeriesData[parameter];
            
            // Sort data points by timestamp
            const sortedIndices = data.timestamps.map((_, idx) => idx)
                .sort((a, b) => data.timestamps[a] - data.timestamps[b]);
            
            const sortedTimestamps = sortedIndices.map(idx => data.timestamps[idx]);
            const sortedValues = sortedIndices.map(idx => data.values[idx]);
            
            // Format dates for display
            const formattedLabels = sortedTimestamps.map(timestamp => formatDate(timestamp));
            
            const ctx = document.getElementById('temporalChart').getContext('2d');
            
            // Create the chart - with styles matching the image
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: formattedLabels,
                    datasets: [{
                        label: `${parameter} (${data.nodeId})`,
                        data: sortedValues,
                        borderColor: '#4a7bfa',          // Blue line color like in the image
                        backgroundColor: 'rgba(74, 123, 250, 0.1)', // Light blue background
                        borderWidth: 2,                  // Slightly thicker line
                        fill: true,                      // Fill area under line
                        tension: 0.2,                    // Smooth curve
                        pointRadius: 3,                  // Point size
                        pointBackgroundColor: '#ffffff', // White point centers
                        pointBorderColor: '#4a7bfa',     // Blue point borders
                        pointBorderWidth: 2              // Point border thickness
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            grid: {
                                display: false           // Hide vertical grid lines
                            },
                            ticks: {
                                maxRotation: 0,          // Don't rotate labels
                                color: '#888888',        // Gray label color
                                font: {
                                    size: 10             // Smaller font size
                                },
                                callback: function(value, index) {
                                    // Show fewer ticks on the x-axis for readability
                                    return index % Math.ceil(formattedLabels.length / 6) === 0 ? 
                                        this.getLabelForValue(value) : '';
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: '#f0f0f0'         // Light gray horizontal grid lines
                            },
                            ticks: {
                                color: '#888888',        // Gray label color
                                font: {
                                    size: 10             // Smaller font size
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#333',
                            bodyColor: '#666',
                            borderColor: '#ddd',
                            borderWidth: 1,
                            cornerRadius: 4,
                            boxPadding: 6,
                            callbacks: {
                                title: function(tooltipItems) {
                                    const idx = tooltipItems[0].dataIndex;
                                    return formatDate(sortedTimestamps[idx]);
                                }
                            }
                        }
                    }
                }
            });
            
            // Update the chart container title
            document.querySelector('.widget-header').textContent = `${parameter} over time`;
            document.getElementById('chartContainer').style.display = 'block';
        }
        
        // Show error message
        function showError(message) {
            const errorElement = document.getElementById('error');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
    </script>
</body>
</html>